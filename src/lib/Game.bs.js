// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Config from "./Config.bs.js";
import * as Random from "rescript/lib/es6/random.js";
import * as Belt_Id from "rescript/lib/es6/belt_Id.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Belt_HashSetInt from "rescript/lib/es6/belt_HashSetInt.js";

var cmp = Caml_obj.compare;

var IntCmp = Belt_Id.MakeComparable({
      cmp: cmp
    });

function safeIndex(x) {
  var j = x[1];
  var i = x[0];
  if (i >= 0 && i < Config.nbcols && j >= 0) {
    return j < Config.nbrows;
  } else {
    return false;
  }
}

function iterGrid(f, board) {
  Belt_Array.forEachWithIndex(board, (function (i, row) {
          Belt_Array.forEachWithIndex(row, (function (j, $$case) {
                  Curry._3(f, [
                        i,
                        j
                      ], $$case, board);
                }));
        }));
}

function makeBlankGrid(width$p, height$p) {
  return Belt_Array.makeBy(width$p, (function (i) {
                return Belt_Array.makeBy(height$p, (function (j) {
                              return {
                                      id: [
                                        i,
                                        j
                                      ],
                                      mined: false,
                                      seen: false,
                                      flag: false,
                                      nbm: 0,
                                      isMine: false
                                    };
                            }));
              }));
}

function generate_seed(param) {
  var t = Date.now();
  var n = t * 10000 | 0;
  Random.init(n % 100000);
}

function random_list_mines(lc, m) {
  var cell_list = Belt_HashSetInt.make(m);
  while(Belt_HashSetInt.size(cell_list) < m) {
    Belt_HashSetInt.add(cell_list, Random.$$int(lc));
  };
  return Belt_HashSetInt.toArray(cell_list);
}

var offset = {
  hd: -1,
  tl: {
    hd: 0,
    tl: {
      hd: 1,
      tl: /* [] */0
    }
  }
};

function getNeighbours(board, param) {
  var j = param[1];
  var i = param[0];
  return Belt_List.map(Belt_List.keep(Belt_List.flatten(Belt_List.map(offset, (function (i$p) {
                            return Belt_List.map(offset, (function (j$p) {
                                          return [
                                                  i + i$p | 0,
                                                  j + j$p | 0
                                                ];
                                        }));
                          }))), (function (p) {
                    if (Caml_obj.notequal(p, [
                            i,
                            j
                          ])) {
                      return safeIndex(p);
                    } else {
                      return false;
                    }
                  })), (function (param) {
                return Caml_array.get(Caml_array.get(board, param[0]), param[1]);
              }));
}

function getNearMines(board, param) {
  return Belt_List.size(Belt_List.keep(getNeighbours(board, [
                      param[0],
                      param[1]
                    ]), (function (param) {
                    return param.isMine;
                  })));
}

function makeRandomGrid(width$p, height$p) {
  generate_seed(undefined);
  var borad = makeBlankGrid(width$p, height$p);
  var random_mines = Belt_Array.map(random_list_mines(Math.imul(Config.nbcols, Config.nbrows), Config.nbmins), (function (num) {
          return [
                  Caml_int32.div(num, Config.nbrows),
                  Caml_int32.mod_(num, Config.nbrows)
                ];
        }));
  Belt_Array.forEach(random_mines, (function (param) {
          Caml_array.get(Caml_array.get(borad, param[0]), param[1]).isMine = true;
        }));
  iterGrid((function (param, param$1, param$2) {
          var j = param[1];
          var i = param[0];
          Caml_array.get(Caml_array.get(borad, i), j).nbm = getNearMines(borad, [
                i,
                j
              ]);
        }), borad);
  return borad;
}

function toggleAll(board) {
  iterGrid((function (param, param$1, param$2) {
          Caml_array.get(Caml_array.get(board, param[0]), param[1]).seen = true;
        }), board);
  return board;
}

function toggleTile(board, $staropt$star, param) {
  var j$p = param[1];
  var i$p = param[0];
  var isFlag = $staropt$star !== undefined ? $staropt$star : false;
  if (isFlag && !Caml_array.get(Caml_array.get(board, i$p), j$p).seen) {
    Caml_array.get(Caml_array.get(board, i$p), j$p).flag = true;
    Caml_array.get(Caml_array.get(board, i$p), j$p).seen = true;
  } else if (Caml_array.get(Caml_array.get(board, i$p), j$p).isMine) {
    toggleAll(board);
  } else if (Caml_array.get(Caml_array.get(board, i$p), j$p).nbm === 0 && (!Caml_array.get(Caml_array.get(board, i$p), j$p).seen || Caml_array.get(Caml_array.get(board, i$p), j$p).flag)) {
    Caml_array.get(Caml_array.get(board, i$p), j$p).seen = true;
    var mines = getNeighbours(board, [
          i$p,
          j$p
        ]);
    Belt_List.forEach(mines, (function (point) {
            return toggleTile(board, undefined, point.id);
          }));
  } else {
    Caml_array.get(Caml_array.get(board, i$p), j$p).seen = true;
    Caml_array.get(Caml_array.get(board, i$p), j$p).flag = false;
  }
  return board;
}

var A;

var S;

var L;

export {
  A ,
  S ,
  L ,
  IntCmp ,
  safeIndex ,
  iterGrid ,
  makeBlankGrid ,
  generate_seed ,
  random_list_mines ,
  offset ,
  getNeighbours ,
  getNearMines ,
  makeRandomGrid ,
  toggleAll ,
  toggleTile ,
}
/* IntCmp Not a pure module */
