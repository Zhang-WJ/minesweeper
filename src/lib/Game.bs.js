// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Config from "./Config.bs.js";
import * as Random from "rescript/lib/es6/random.js";
import * as Belt_Id from "rescript/lib/es6/belt_Id.js";
import * as Belt_Set from "rescript/lib/es6/belt_Set.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Belt_HashSetInt from "rescript/lib/es6/belt_HashSetInt.js";

var cmp = Caml_obj.compare;

var PointCmp = Belt_Id.MakeComparable({
      cmp: cmp
    });

function safeIndex(x) {
  var j = x[1];
  var i = x[0];
  if (i >= 0 && i < Config.nbcols && j >= 0) {
    return j < Config.nbrows;
  } else {
    return false;
  }
}

function mapGrid(f, board) {
  return Belt_Array.mapWithIndex(board, (function (i, row) {
                return Belt_Array.mapWithIndex(row, (function (j, $$case) {
                              return Curry._3(f, [
                                          i,
                                          j
                                        ], $$case, board);
                            }));
              }));
}

function makeBlankGrid(width$p, height$p) {
  return Belt_Array.makeBy(width$p, (function (i) {
                return Belt_Array.makeBy(height$p, (function (j) {
                              return {
                                      id: [
                                        i,
                                        j
                                      ],
                                      mined: false,
                                      seen: false,
                                      flag: false,
                                      nbm: 0,
                                      isMine: false
                                    };
                            }));
              }));
}

function generate_seed(param) {
  var t = Date.now();
  var n = t * 10000 | 0;
  Random.init(n % 100000);
}

function random_list_mines(lc, m) {
  var cell_list = Belt_HashSetInt.make(m);
  while(Belt_HashSetInt.size(cell_list) < m) {
    Belt_HashSetInt.add(cell_list, Random.$$int(lc));
  };
  return Belt_HashSetInt.toArray(cell_list);
}

var offset = {
  hd: -1,
  tl: {
    hd: 0,
    tl: {
      hd: 1,
      tl: /* [] */0
    }
  }
};

function getNeighbours(board, param) {
  var j = param[1];
  var i = param[0];
  return Belt_List.map(Belt_List.keep(Belt_List.flatten(Belt_List.map(offset, (function (i$p) {
                            return Belt_List.map(offset, (function (j$p) {
                                          return [
                                                  i + i$p | 0,
                                                  j + j$p | 0
                                                ];
                                        }));
                          }))), (function (p) {
                    if (Caml_obj.notequal(p, [
                            i,
                            j
                          ])) {
                      return safeIndex(p);
                    } else {
                      return false;
                    }
                  })), (function (param) {
                return Caml_array.get(Caml_array.get(board, param[0]), param[1]);
              }));
}

function getNearMines(board, param) {
  return Belt_List.size(Belt_List.keep(getNeighbours(board, [
                      param[0],
                      param[1]
                    ]), (function (param) {
                    return param.isMine;
                  })));
}

function makeRandomGrid(width$p, height$p) {
  generate_seed(undefined);
  var random_mines = Belt_Array.map(random_list_mines(Math.imul(Config.nbcols, Config.nbrows), Config.nbmins), (function (num) {
          return [
                  Caml_int32.div(num, Config.nbrows),
                  Caml_int32.mod_(num, Config.nbrows)
                ];
        }));
  return mapGrid((function (param, case$p, board) {
                return {
                        id: case$p.id,
                        mined: case$p.mined,
                        seen: case$p.seen,
                        flag: case$p.flag,
                        nbm: getNearMines(board, [
                              param[0],
                              param[1]
                            ]),
                        isMine: case$p.isMine
                      };
              }), mapGrid((function (param, $$case, param$1) {
                    var y = param[1];
                    var x = param[0];
                    return {
                            id: $$case.id,
                            mined: $$case.mined,
                            seen: $$case.seen,
                            flag: $$case.flag,
                            nbm: $$case.nbm,
                            isMine: Belt_Array.some(random_mines, (function (param) {
                                    if (x === param[0]) {
                                      return y === param[1];
                                    } else {
                                      return false;
                                    }
                                  }))
                          };
                  }), makeBlankGrid(width$p, height$p)));
}

function toggleAll(board) {
  return mapGrid((function (param, $$case, param$1) {
                return {
                        id: $$case.id,
                        mined: $$case.mined,
                        seen: true,
                        flag: $$case.flag,
                        nbm: $$case.nbm,
                        isMine: $$case.isMine
                      };
              }), board);
}

function getUnMinePoints(board, point, acc) {
  var neighbours = Belt_List.keep(getNeighbours(board, point.id), (function (point) {
          return Belt_List.every(acc, (function (pos) {
                        if (Caml_obj.notequal(pos, point.id)) {
                          return !point.isMine;
                        } else {
                          return false;
                        }
                      }));
        }));
  var a = point.nbm > 0 ? acc : Belt_List.concat(acc, Belt_List.map(neighbours, (function (point) {
                return point.id;
              })));
  if (Belt_List.size(neighbours) > 0 && point.nbm === 0) {
    return Belt_List.flatten(Belt_List.map(neighbours, (function (point) {
                      return getUnMinePoints(board, point, a);
                    })));
  } else {
    return a;
  }
}

function toggleTile(board, isFlagOpt, cell) {
  var isFlag = isFlagOpt !== undefined ? isFlagOpt : false;
  var match = cell.seen;
  var match$1 = cell.isMine;
  if (match) {
    return board;
  }
  if (match$1) {
    if (!isFlag) {
      return toggleAll(board);
    }
    
  } else if (!isFlag) {
    var needShow = Belt_Set.toList(Belt_Set.fromArray(Belt_List.toArray(getUnMinePoints(board, cell, {
                      hd: cell.id,
                      tl: /* [] */0
                    })), PointCmp));
    return mapGrid((function (param, $$case, param$1) {
                  if (Belt_List.some(needShow, (function (point) {
                            return Caml_obj.equal($$case.id, point);
                          }))) {
                    return {
                            id: $$case.id,
                            mined: $$case.mined,
                            seen: true,
                            flag: $$case.flag,
                            nbm: $$case.nbm,
                            isMine: $$case.isMine
                          };
                  } else {
                    return $$case;
                  }
                }), board);
  }
  return mapGrid((function (param, $$case, param$1) {
                if (Caml_obj.equal($$case.id, cell.id)) {
                  return {
                          id: $$case.id,
                          mined: $$case.mined,
                          seen: true,
                          flag: true,
                          nbm: $$case.nbm,
                          isMine: $$case.isMine
                        };
                } else {
                  return $$case;
                }
              }), board);
}

var A;

var S;

var L;

export {
  A ,
  S ,
  L ,
  PointCmp ,
  safeIndex ,
  mapGrid ,
  makeBlankGrid ,
  generate_seed ,
  random_list_mines ,
  offset ,
  getNeighbours ,
  getNearMines ,
  makeRandomGrid ,
  toggleAll ,
  getUnMinePoints ,
  toggleTile ,
}
/* PointCmp Not a pure module */
